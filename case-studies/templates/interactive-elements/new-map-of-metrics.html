<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive KPI to Intrinsic Enterprise Value Mind Map</title>
    <!-- D3.js Library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <!-- Tailwind CSS for modern UI styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        /* Custom styles for the visualization */
        body {
            margin: 0;
            padding: 0;
            font-family: 'Inter', sans-serif;
            background-color: #f3f4f6; /* Very light gray background */
            overflow: hidden; /* Prevent scrollbars on the body */
        }

        #container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }
        
        /* Styling for SVG links (lines between nodes) */
        .link {
            fill: none;
            stroke: #9ca3af; /* Gray-400 */
            stroke-opacity: 0.6;
            stroke-width: 1.5px;
        }

        /* Styling for SVG nodes (rectangles and text) */
        .node {
            cursor: pointer; /* Change cursor to pointer on hover */
        }
        
        .node rect {
            transition: filter 0.3s ease, stroke-width 0.3s ease, stroke 0.3s ease;
            stroke-width: 2px;
        }
        
        .node:hover rect {
            filter: brightness(1.1);
        }
        
        /* Style for text labels on nodes */
        .node-label {
            font-size: 12px;
            fill: #1f2937; /* Dark Gray for readability */
            pointer-events: none; /* Text should not block mouse events */
            user-select: none;
        }

        /* Specific font sizes for different node types */
        .center-label { font-size: 16px; font-weight: 700; }
        .strategicObjective-label { font-size: 14px; font-weight: 600; }
        .tacticalKeyResult-label { font-size: 13px; }
        .managerialKpi-label { font-size: 12px; }

    </style>
</head>
<body class="bg-gray-100">
    <!-- Main container for the D3 visualization -->
    <div id="container">
        <!-- Bottom-right legend panel -->
        <div class="legend absolute bottom-5 right-5 bg-white bg-opacity-70 backdrop-blur-sm p-4 rounded-lg shadow-lg text-gray-800 pointer-events-none">
            <h4 class="font-bold text-sm mb-2">Legend</h4>
            <div class="space-y-2">
                <div class="flex items-center">
                    <div class="w-4 h-4 rounded mr-3" style="background: #34D399;"></div><span class="text-xs">Intrinsic Enterprise Value</span>
                </div>
                <div class="flex items-center">
                    <div class="w-4 h-4 rounded mr-3" style="background: #60A5FA;"></div><span class="text-xs">Strategic Objective</span>
                </div>
                <div class="flex items-center">
                    <div class="w-4 h-4 rounded mr-3" style="background: #FBBF24;"></div><span class="text-xs">Tactical Key Result</span>
                </div>
                <div class="flex items-center">
                    <div class="w-4 h-4 rounded mr-3" style="background: #A78BFA;"></div><span class="text-xs">Managerial KPI</span>
                </div>
                 <div class="flex items-center">
                    <div class="w-4 h-4 rounded mr-3 border border-gray-400" style="background: #FFFFFF;"></div><span class="text-xs">KPI Descendant (N, N+2...)</span>
                </div>
                 <div class="flex items-center">
                    <div class="w-4 h-4 rounded mr-3" style="background: #1f2937;"></div><span class="text-xs">KPI Descendant (N+1, N+3...)</span>
                </div>
            </div>
        </div>
        <!-- Bottom-left rebalance button -->
        <button id="rebalance-btn" class="absolute bottom-5 left-5 bg-gray-200 text-gray-700 hover:bg-gray-900 hover:text-gray-100 font-bold py-2 px-4 rounded-lg shadow-lg transition-colors duration-300 border border-gray-700 hover:border-gray-100">Rebalance</button>
    </div>

    <script>
        // --- DATA LOADING ---
        // This is the only line you need to change for each new map.
        // Point this to the new JSON file for each case study.
        const dataPath = "./map-of-metrics-data-extended.json"; 

        d3.json(dataPath).then(function(sourceData) {
            // Data loaded successfully, now initialize the visualization
            initializeVisualization(sourceData);
        }).catch(function(error) {
            console.error("Error loading the data file:", error);
            // Display an error message if the file can't be found or is invalid
            const container = document.getElementById('container');
            container.innerHTML = `<div class="w-full h-full flex items-center justify-center text-red-600 font-semibold p-8 text-center">
                Error: Could not load mind map data from '${dataPath}'.<br/>Please check the file path and make sure the JSON is correctly formatted. This often happens when running the file locally instead of on a web server.
            </div>`;
        });


        // This function contains all the logic to draw the mind map.
        // It only runs after the data has been loaded successfully.
        function initializeVisualization(sourceData) {
            // --- D3 SETUP ---
            const containerEl = document.getElementById('container');
            let width = containerEl.clientWidth;
            let height = containerEl.clientHeight;
            const transitionDuration = 750;
            let isRebalanced = false;

            const svg = d3.select("#container").append("svg")
                .attr("width", width)
                .attr("height", height)
                .attr("viewBox", [-width / 2, -height / 2, width, height]);

            const g = svg.append("g");
            let link = g.append("g").attr("class", "links").selectAll("path.link");
            let node = g.append("g").attr("class", "nodes").selectAll(".node");

            // --- SCALES & COLORING LOGIC ---
            const colorScale = d3.scaleOrdinal()
                .domain(["center", "strategicObjective", "tacticalKeyResult", "managerialKpi"])
                .range(["#34D399", "#60A5FA", "#FBBF24", "#A78BFA"]);

            // NEW: Function to determine node background color
            function getNodeColor(d) {
                const kpiDepth = 3; // The depth of "managerialKpi" nodes is 3
                if (d.depth <= kpiDepth) {
                    return colorScale(d.data.type); // Use original colors for main hierarchy
                }
                // For descendants of KPIs, alternate colors based on depth
                const depthAfterKpi = d.depth - (kpiDepth + 1);
                return depthAfterKpi % 2 === 0 ? "#FFFFFF" : "#1f2937"; // White, then Black
            }

            // NEW: Function to determine text color for contrast
            function getTextColor(d) {
                const kpiDepth = 3;
                if (d.depth <= kpiDepth) {
                    return "#1f2937"; // Default dark text
                }
                const depthAfterKpi = d.depth - (kpiDepth + 1);
                return depthAfterKpi % 2 === 0 ? "#1f2937" : "#FFFFFF"; // Black text on white, White text on black
            }

            // --- SIMULATION ---
            const simulation = d3.forceSimulation()
                .force("link", d3.forceLink().id(d => d.id).distance(120).strength(0.8))
                .force("charge", d3.forceManyBody().strength(-1500))
                .force("center", d3.forceCenter(0, 0))
                .force("collision", d3.forceCollide().radius(d => Math.max(d.width / 2, d.height / 2) + 15))
                .on("tick", ticked);
            
            // --- DATA PROCESSING & INITIAL RENDER ---
            const root = d3.hierarchy(sourceData);
            root.descendants().forEach((d, i) => {
                d.id = i;
                d._children = d.children;
                // Collapse all nodes deeper than the first level initially
                if (d.depth > 1) d.children = null;
            });
            
            update();

            function wrapAndSize(selection) {
                const PADDING = 10;
                const LINE_HEIGHT = 1.2;
                const MAX_WIDTH = 200;
                selection.each(function(d) {
                    const textEl = d3.select(this);
                    const words = d.data.name.split(/\s+/);
                    textEl.text(null);
                    let tspan = textEl.append('tspan').attr('x', 0);
                    tspan.text(d.data.name);
                    if (tspan.node().getComputedTextLength() > MAX_WIDTH) {
                        tspan.text('');
                        let bestSplit = findBestSplitPoint(words);
                        const line1 = words.slice(0, bestSplit).join(' ');
                        const line2 = words.slice(bestSplit).join(' ');
                        textEl.append('tspan').attr('x', 0).text(line1);
                        textEl.append('tspan').attr('x', 0).attr('dy', `${LINE_HEIGHT}em`).text(line2);
                    }
                    const bbox = textEl.node().getBBox();
                    d.width = bbox.width + PADDING * 2;
                    d.height = bbox.height + PADDING * 2;
                    textEl.attr('y', -bbox.height / 2 - bbox.y);
                });
            }
            
            function findBestSplitPoint(words) {
                let bestSplit = -1, minDiff = Infinity;
                for (let i = 1; i < words.length; i++) {
                    const l1 = words.slice(0, i).join(' ').length;
                    const l2 = words.slice(i).join(' ').length;
                    const diff = Math.abs(l1 - l2);
                    if (diff < minDiff) {
                        minDiff = diff;
                        bestSplit = i;
                    }
                }
                return bestSplit;
            }

            // --- CORE UPDATE FUNCTION ---
            function update() {
                const nodes = root.descendants().filter(d => d.parent ? d.parent.children : true);
                const links = root.links().filter(d => d.source.children && d.target.parent.children);

                if (isRebalanced) {
                    rebalanceLayout();
                    return;
                }

                link = link.data(links, d => d.target.id);
                link.exit().remove();
                link = link.enter().append("path").attr("class", "link").merge(link);

                node = node.data(nodes, d => d.id);
                node.exit().transition().duration(transitionDuration)
                    .attr("transform", d => `translate(${d.parent.x},${d.parent.y})`)
                    .style("opacity", 0)
                    .remove();
                
                const nodeEnter = node.enter().append("g")
                    .attr("class", "node")
                    .attr("transform", d => `translate(${d.parent ? d.parent.x : 0},${d.parent ? d.parent.y : 0})`)
                    .style("opacity", 0)
                    .on("click", (event, d) => {
                        if (event.defaultPrevented) return;
                        toggleChildren(d);
                    })
                    .call(drag(simulation));

                nodeEnter.append("rect");
                
                // MODIFIED: Apply text color dynamically
                nodeEnter.append("text")
                    .attr("class", d => `node-label ${d.data.type ? d.data.type + '-label' : ''}`)
                    .attr("text-anchor", "middle")
                    .style("fill", d => getTextColor(d))
                    .call(wrapAndSize);
                
                // MODIFIED: Apply background and stroke color dynamically
                nodeEnter.select("rect")
                    .attr("width", d => d.width)
                    .attr("height", d => d.height)
                    .attr("x", d => -d.width / 2)
                    .attr("y", d => -d.height / 2)
                    .attr("rx", 5)
                    .attr("fill", d => getNodeColor(d))
                    .attr("stroke", d => d3.color(getNodeColor(d)).darker(0.6));

                node = nodeEnter.merge(node);
                
                node.transition().duration(transitionDuration).style("opacity", 1);
                
                // MODIFIED: Update stroke logic for collapsed nodes
                node.select('rect')
                    .transition().duration(transitionDuration)
                    .attr("stroke", d => (d._children && !d.children) ? "#1f2937" : d3.color(getNodeColor(d)).darker(0.6))
                    .attr("stroke-width", d => (d._children && !d.children) ? 4 : 2);
                
                simulation.nodes(nodes);
                simulation.force("link").links(links);
                simulation.alpha(1).restart();
            }
            
            function ticked() {
                if (!isRebalanced) {
                    node.attr("transform", d => `translate(${d.x},${d.y})`);
                    link.attr("d", d => {
                        const dx = d.target.x - d.source.x, dy = d.target.y - d.source.y;
                        const length = Math.sqrt(dx * dx + dy * dy);
                        const mx = (d.source.x + d.target.x) / 2, my = (d.source.y + d.target.y) / 2;
                        const px = -dy / length, py = dx / length;
                        const offset = 30; 
                        const cx = mx + offset * px, cy = my + offset * py;
                        return `M${d.source.x},${d.source.y} Q${cx},${cy} ${d.target.x},${d.target.y}`;
                    });
                }
            }

            function toggleChildren(d) {
                if (d.children) {
                    d.children = null;
                } else {
                    d.children = d._children;
                }
                update();
            }

            function drag(simulation) {
                function dragstarted(event, d) {
                    if (isRebalanced) {
                        unfixAllNodes();
                        update();
                    }
                    if (!event.active) simulation.alphaTarget(0.3).restart();
                    d.fx = d.x;
                    d.fy = d.y;
                }
                function dragged(event, d) {
                    d.fx = event.x;
                    d.fy = event.y;
                }
                function dragended(event, d) {
                    if (!event.active) simulation.alphaTarget(0);
                    if (isRebalanced) {
                        d.fx = event.x;
                        d.fy = event.y;
                    } else {
                        d.fx = null;
                        d.fy = null;
                    }
                }
                return d3.drag().on("start", dragstarted).on("drag", dragged).on("end", dragended);
            }

            const zoom = d3.zoom().scaleExtent([0.1, 5]).on("zoom", (event) => g.attr("transform", event.transform));
            svg.call(zoom);
            
            function handleResize() {
                width = containerEl.clientWidth;
                height = containerEl.clientHeight;
                svg.attr("viewBox", [-width / 2, -height / 2, width, height]);
                if (isRebalanced) {
                    rebalanceLayout();
                } else {
                    simulation.force("center", d3.forceCenter(0, 0)).restart();
                }
            }
            window.addEventListener('resize', handleResize);

            function unfixAllNodes() {
                node.each(d => {
                    d.fx = null;
                    d.fy = null;
                });
                isRebalanced = false;
            }

            function rebalanceLayout() {
                isRebalanced = true;
                simulation.stop();
                svg.transition().duration(transitionDuration).call(zoom.transform, d3.zoomIdentity);

                const allNodes = root.descendants().filter(d => d.parent ? d.parent.children : true);
                const centerNode = allNodes.find(d => d.data.type === 'center');
                if (!centerNode) return;

                centerNode.fx = 0;
                centerNode.fy = 0;

                let hasCollisions = true;
                let iterations = 0;
                const maxIterations = 50; 
                
                // MODIFIED: Extended radii to handle deeper levels in the rebalance view
                let radii = {
                    1: Math.max(centerNode.width, centerNode.height) / 2 + 120,
                    2: Math.max(centerNode.width, centerNode.height) / 2 + 320,
                    3: Math.max(centerNode.width, centerNode.height) / 2 + 520,
                    4: Math.max(centerNode.width, centerNode.height) / 2 + 720,
                    5: Math.max(centerNode.width, centerNode.height) / 2 + 920,
                };

                while (hasCollisions && iterations < maxIterations) {
                    iterations++;
                    hasCollisions = false;

                    const strategicObjectives = allNodes.filter(d => d.data.type === 'strategicObjective');
                    const strategicObjectiveAngleSlice = (2 * Math.PI) / strategicObjectives.length;

                    strategicObjectives.forEach((strategicObj, i) => {
                        const strategicObjAngle = i * strategicObjectiveAngleSlice;
                        strategicObj.fx = radii[1] * Math.cos(strategicObjAngle);
                        strategicObj.fy = radii[1] * Math.sin(strategicObjAngle);

                        const tacticalKeyResults = strategicObj.children ? allNodes.filter(n => n.parent === strategicObj) : [];
                        if (tacticalKeyResults.length > 0) {
                            const tacticalKeyResultAngleSlice = strategicObjectiveAngleSlice / tacticalKeyResults.length;
                            const tacticalKeyResultStartAngle = strategicObjAngle - (strategicObjectiveAngleSlice / 2);

                            tacticalKeyResults.forEach((tacticalKeyResult, j) => {
                                const tacticalKeyResultAngle = tacticalKeyResultStartAngle + (j * tacticalKeyResultAngleSlice) + (tacticalKeyResultAngleSlice / 2);
                                tacticalKeyResult.fx = radii[2] * Math.cos(tacticalKeyResultAngle);
                                tacticalKeyResult.fy = radii[2] * Math.sin(tacticalKeyResultAngle);

                                const managerialKpis = tacticalKeyResult.children ? allNodes.filter(n => n.parent === tacticalKeyResult) : [];
                                if (managerialKpis.length > 0) {
                                    const managerialKpiAngleSlice = tacticalKeyResultAngleSlice / managerialKpis.length;
                                    const managerialKpiStartAngle = tacticalKeyResultAngle - (tacticalKeyResultAngleSlice / 2);

                                    managerialKpis.forEach((managerialKpi, k) => {
                                        const managerialKpiAngle = managerialKpiStartAngle + (k * managerialKpiAngleSlice) + (managerialKpiAngleSlice / 2);
                                        managerialKpi.fx = radii[3] * Math.cos(managerialKpiAngle);
                                        managerialKpi.fy = radii[3] * Math.sin(managerialKpiAngle);
                                        
                                        // NEW: Added layout logic for one level deeper (N)
                                        const subKpis = managerialKpi.children ? allNodes.filter(n => n.parent === managerialKpi) : [];
                                        if (subKpis.length > 0) {
                                            const subKpiAngleSlice = managerialKpiAngleSlice / subKpis.length;
                                            const subKpiStartAngle = managerialKpiAngle - (managerialKpiAngleSlice / 2);
                                            subKpis.forEach((subKpi, l) => {
                                                const subKpiAngle = subKpiStartAngle + (l * subKpiAngleSlice) + (subKpiAngleSlice / 2);
                                                subKpi.fx = radii[4] * Math.cos(subKpiAngle);
                                                subKpi.fy = radii[4] * Math.sin(subKpiAngle);
                                            });
                                        }
                                    });
                                }
                            });
                        }
                    });

                    for (let i = 0; i < allNodes.length; i++) {
                        const d = allNodes[i];
                        const r1 = { x1: d.fx - d.width/2, y1: d.fy - d.height/2, x2: d.fx + d.width/2, y2: d.fy + d.height/2 };
                        for (let j = i + 1; j < allNodes.length; j++) {
                            const q = allNodes[j];
                            const r2 = { x1: q.fx - q.width/2, y1: q.fy - q.height/2, x2: q.fx + q.width/2, y2: q.fy + q.height/2 };
                            if (r1.x1 < r2.x2 && r1.x2 > r2.x1 && r1.y1 < r2.y2 && r1.y2 > r2.y1) {
                                hasCollisions = true;
                                break; 
                            }
                        }
                        if (hasCollisions) break;
                    }

                    if (hasCollisions) {
                        const radiusIncrement = 10;
                        radii[1] += radiusIncrement;
                        radii[2] += radiusIncrement * 1.5;
                        radii[3] += radiusIncrement * 2.0;
                        radii[4] += radiusIncrement * 2.5;
                        radii[5] += radiusIncrement * 3.0;
                    }
                }
                
                allNodes.forEach(d => {
                    d.x = d.fx;
                    d.y = d.fy;
                });
                simulation.nodes(allNodes);
                simulation.alpha(0.3).restart();

                node.transition().duration(transitionDuration)
                    .attr("transform", d => `translate(${d.fx},${d.fy})`);
                    
                const links = root.links().filter(d => d.source.children && d.target.parent.children);
                link = link.data(links, d => d.target.id);
                link.transition().duration(transitionDuration)
                    .attr("d", d => {
                        const dx = d.target.fx - d.source.fx, dy = d.target.fy - d.source.fy;
                        const length = Math.sqrt(dx * dx + dy * dy);
                        const mx = (d.source.fx + d.target.fx) / 2, my = (d.source.fy + d.target.fy) / 2;
                        const px = -dy / length, py = dx / length;
                        const offset = 30; 
                        const cx = mx + offset * px, cy = my + offset * py;
                        return `M${d.source.fx},${d.source.fy} Q${cx},${cy} ${d.target.fx},${d.target.fy}`;
                    });
            }

            d3.select("#rebalance-btn").on("click", () => {
                 if (isRebalanced) {
                    unfixAllNodes();
                    update();
                 } else {
                    rebalanceLayout();
                 }
            });
        }
    </script>
</body>
</html>
